#' @param df_ph dataframe containing phosphoproteomics data.
#' @param threshold numeric, it specifies the threshold percentage of zeros in each row the transcriptomic dataframe. If there are >= threshold percentage of
#'                  zeros in a row, the row will be removed (default: 80).
#' @param sw_len integer, the sequence window length. It could be 7 or 15 (default: 7).
#' @param uniprot_idx optional integer indicating the column index for UNIPROT IDs to be added at the uniprot column retrieved with AnnotationDbi (default is NULL).
#' @param pep_col_name string, it indicates the name of the peptide sequence column (if it's present) in your phosphoproteomic dataframe (default = "Peptide")
#' @param imp_method string, the method to use for imputation (default: "pmm", but you can choose between "pmm", "norm", "norm.nob",
#'                   "regression", "ri", "logreg", "polyreg", "predictive", "polr", "sample", "cart", "knn", "rf").
#' @param zscore logical, whether to perform Z-score normalization (default: "TRUE").
#' @param zmethod string, specifies whether Z-score normalization is performed by "row" or "column" (default: "column").
#' @param metric string, the centering metric for Z-score normalization. Options are "median" (default) or "mean".
#' @param output_dir a string indicating the updated output folder.
#'
#' @return This function updates the following global variables:
#'
#' transctriptomics_updated -> A data frame containing the updated transcriptomics data.
#' proteomics_updated -> A data frame containing the updated proteomics data.
#' phosphoproteomics_updated -> A data frame containing the updated phosphoproteomics data.
#'
#' @examples
#' transcriptomics_data <- data.frame(matrix(rnorm(100), nrow = 10))
#' proteomics_data <- data.frame(matrix(rnorm(100), nrow = 10))
#' phosphoproteomics_data <- data.frame(matrix(rnorm(100), nrow = 10))
#'
#' omics_update(
#'   df_tr = transcriptomics_data,
#'   df_pr = proteomics_data,
#'   df_ph = phosphoproteomics_data,
#'   sw_len = 7,
#'   imp_method = "pmm",
#'   zscore = TRUE,
#'   zmethod = "column",
#'   metric = "median"
#' )
#'
#' @export
omics_update <- function(df_tr = NULL,
df_pr = NULL,
df_ph = NULL,
threshold = 80,
sw_len = 7,
uniprot_idx = NULL,
pep_col_name = NULL,
imp_method = "pmm",
zscore = "TRUE",
zmethod = "column",
metric = "median",
output_dir = "PatientProfiler_processed_input") {
if(!dir.exists(output_dir)){
dir.create(output_dir)
}
if (!is.null(sw_len) && !sw_len %in% c(7, 15)) {
stop("sw_len parameter has to be 7, 15 or NULL (if you do not have the phosphoproteomics dataframe")
}
if (!is.null(df_tr)) {
message("Transcriptomics update started..")
transcriptomics_updated <<- transcriptomics_update(df_tr,threshold,zscore,zmethod,metric,output_dir)
readr::write_tsv(transcriptomics_updated, paste0(output_dir,"/","Transcriptomics_updated.tsv"))
message("Transcriptomics update complete!")
}
if(!is.null(df_pr)){
message("Proteomics update started..")
proteomics_updated <<- proteomics_update(df_pr,imp_method,zscore,zmethod,metric, output_dir)
readr::write_tsv(proteomics_updated, paste0(output_dir,"/","Proteomics_updated.tsv"))
message("Proteomics update complete!")
}
if(!is.null(df_ph)){
message("Phosphoproteomics update started..")
phosphoproteomics_updated <<- phosphoproteomics_update(df_pho = df_ph,
sw_len = 7,
uniprot_idx,
pep_col_name = pep_col_name,
imp_method,
zscore,
zmethod,
metric,
output_dir)
readr::write_tsv(phosphoproteomics_updated, paste0(output_dir,"/","Phosphoproteomics_updated.tsv"))
message("Phosphoproteomics update complete!")
}
}
debug(omics_update)
View(aa)
bb <- omics_update(df_ph = aa,pep_col_name = "Peptide")
knitr::opts_chunk$set(echo = TRUE)
folder <- "~/Desktop/Lab/Projets/PatientProfiler_analysis/PatientProfiler-main/R/"
file_scripts <- list.files(folder, pattern = "\\.R$", full.names = TRUE)
for (file in file_scripts) {
source(file)
}
prot <- read_tsv("~/Desktop/Lab/CPTAC_data_analysis/CPTAC/V1/Brca/Brca_prot.tsv",show_col_types = FALSE)
library(readr)
library(dplyr)
folder <- "~/Desktop/Lab/Projets/PatientProfiler_analysis/PatientProfiler-main/R/"
file_scripts <- list.files(folder, pattern = "\\.R$", full.names = TRUE)
for (file in file_scripts) {
source(file)
}
prot <- read_tsv("~/Desktop/Lab/CPTAC_data_analysis/CPTAC/V1/Brca/Brca_prot.tsv",show_col_types = FALSE)
phospho <- read_tsv("~/Desktop/Lab/CPTAC_data_analysis/CPTAC/V1/Brca/Brca_phospho.tsv",show_col_types = FALSE)
transc <- read_tsv("~/Desktop/Lab/CPTAC_data_analysis/CPTAC/V1/Brca/Brca_transc.tsv",show_col_types = FALSE)
debug(update_phospho)
phospho_upd <- update_phospho(phospho, 2, 1, peptide_col_name = "Peptide")
View(df5)
mult_values <- df4[[mult_col]]
if (length(unique(mult_values[!is.na(mult_values)])) > 1) {
df5 <- remove_multiplicity(df4, peptide_col, mult_col, gn_idx)
} else {
df5 <- df4
}
library(readr)
library(dplyr)
folder <- "~/Desktop/Lab/Projets/PatientProfiler_analysis/PatientProfiler-main/R/"
file_scripts <- list.files(folder, pattern = "\\.R$", full.names = TRUE)
for (file in file_scripts) {
source(file)
}
phospho_upd <- update_phospho(phospho, 2, 1, peptide_col_name = "Peptide")
debug(update_phospho)
phospho_upd <- update_phospho(phospho, 2, 1, peptide_col_name = "Peptide")
View(update_phospho)
debug(update_phospho)
View(phospho)
add_multiplicity <- function(df, peptide_col) {
if (any(grepl("[*]", df[[peptide_col]]))) {
pattern <- "[*]"
} else {
pattern <- "[a-z]"
}
df$Multiplicity <- stringr::str_count(df[[peptide_col]], pattern)
return(df)
}
df <- data.frame(Peptide = c("sRsRsTPVRR", "LLsFRsMEEAR", "SATTTPSG*PR"))
View(df)
df <- add_multiplicity(df, "Peptide")
View(df)
print(df)
add_multiplicity <- function(df, peptide_col) {
# Conta separatamente gli asterischi e le lettere minuscole
count_star <- stringr::str_count(df[[peptide_col]], "[*]")
count_lower <- stringr::str_count(df[[peptide_col]], "[a-z]")
# Usa la colonna che ha più variabilità (cioè >1 valore unico)
if (length(unique(count_star)) > 1) {
df$Multiplicity <- count_star
} else {
df$Multiplicity <- count_lower
}
return(df)
}
df <- data.frame(Peptide = c("sRsRsTPVRR", "LLsFRsMEEAR", "SATTTPSG*PR"))
df <- add_multiplicity(df, "Peptide")
View(df)
add_multiplicity <- function(df, peptide_col) {
# Conta separatamente gli asterischi e le lettere minuscole
count_star <- stringr::str_count(df[[peptide_col]], "[*]")
count_lower <- stringr::str_count(df[[peptide_col]], "[a-z]")
# Usa la colonna che ha più variabilità (cioè >1 valore unico)
if (length(unique(count_star)) > 1) {
df$Multiplicity <- count_star
} else {
df$Multiplicity <- count_lower
}
return(df)
}
df <- data.frame(Peptide = c("sRsRsTPVRR", "LLsFRsMEEAR", "SATTTPSG*PR"))
df <- add_multiplicity(df, "Peptide")
print(df)
add_multiplicity <- function(df, peptide_col) {
# Conta le lettere minuscole (s, t, y...) e gli asterischi
count_lower <- stringr::str_count(df[[peptide_col]], "[a-z]")
count_star <- stringr::str_count(df[[peptide_col]], "\\*")
# Somma entrambe le modalità
df$Multiplicity <- count_lower + count_star
return(df)
}
df <- data.frame(Peptide = c("sRsRsTPVRR", "LLsFRsMEEAR", "SATTTPSG*PR"))
df <- add_multiplicity(df, "Peptide")
df <- add_multiplicity(df, "Peptide")
print(df)
library(readr)
library(dplyr)
folder <- "~/Desktop/Lab/Projets/PatientProfiler_analysis/PatientProfiler-main/R/"
file_scripts <- list.files(folder, pattern = "\\.R$", full.names = TRUE)
for (file in file_scripts) {
source(file)
}
prot <- read_tsv("~/Desktop/Lab/CPTAC_data_analysis/CPTAC/V1/Brca/Brca_prot.tsv",show_col_types = FALSE)
phospho <- read_tsv("~/Desktop/Lab/CPTAC_data_analysis/CPTAC/V1/Brca/Brca_phospho.tsv",show_col_types = FALSE)
transc <- read_tsv("~/Desktop/Lab/CPTAC_data_analysis/CPTAC/V1/Brca/Brca_transc.tsv",show_col_types = FALSE)
debug(update_phospho)
phospho_upd <- update_phospho(phospho, 2, 1, peptide_col_name = "Peptide")
View(df4)
add_multiplicity <- function(df, peptide_col) {
count_lower <- stringr::str_count(df[[peptide_col]], "[a-z]")
count_star <- stringr::str_count(df[[peptide_col]], "\\*")
df$Multiplicity <- count_lower + count_star
return(df)
}
df4 <- add_multiplicity(df3,peptide_col = "Peptide")
View(df4)
View(df3)
Q
library(readr)
library(dplyr)
folder <- "~/Desktop/Lab/Projets/PatientProfiler_analysis/PatientProfiler-main/R/"
file_scripts <- list.files(folder, pattern = "\\.R$", full.names = TRUE)
for (file in file_scripts) {
source(file)
}
prot <- read_tsv("~/Desktop/Lab/CPTAC_data_analysis/CPTAC/V1/Brca/Brca_prot.tsv",show_col_types = FALSE)
phospho <- read_tsv("~/Desktop/Lab/CPTAC_data_analysis/CPTAC/V1/Brca/Brca_phospho.tsv",show_col_types = FALSE)
transc <- read_tsv("~/Desktop/Lab/CPTAC_data_analysis/CPTAC/V1/Brca/Brca_transc.tsv",show_col_types = FALSE)
debug(update_phospho)
phospho_upd <- update_phospho(phospho, 2, 1, peptide_col_name = "Peptide")
df = phospho
site_col = 2
gn_idx = 1
seq_len_i=7
uniprot_idx = NULL
peptide_col_name = "Peptide"
# Step 1: Clear invalid sites
df1 <- remove_invalid_site(df, site_col)
# Step 2: Retrieve primary gene names
df2 <- retrieve_primary_gene_name(df1, gn_idx, uniprot_idx)
# Identify the sequence column
sequence_col <- which(colnames(df2) == "Sequence")
# Step 3: Check if peptide_col_name is provided and exists in df
if (!is.null(peptide_col_name) && peptide_col_name %in% colnames(df)) {
peptide_col <- which(colnames(df) == peptide_col_name)
} else {
peptide_col <- NULL
}
if (!is.null(peptide_col))
# Step 4: Clean multiple peptides
df3 <- clean_multiple_peptide(df2, peptide_col)
# Step 5: Add multiplicity information
df4 <- add_multiplicity(df3, peptide_col)
mult_col <- which(colnames(df4) == "Multiplicity")
mult_values <- df4[[mult_col]]
if (length(unique(mult_values[!is.na(mult_values)])) > 1) {
df5 <- remove_multiplicity(df4, peptide_col, mult_col, gn_idx)
} else {
df5 <- df4
}
if (length(unique(mult_values[!is.na(mult_values)])) > 1) {
df5 <- remove_multiplicity(df4, peptide_col, mult_col, gn_idx)
} else {
df5 <- df4
}
View(df5)
View(df4)
# Step 5: Add multiplicity information
df4 <- add_multiplicity(df3, peptide_col)
mult_col <- which(colnames(df4) == "Multiplicity")
mult_values <- df4[[mult_col]]
mult_values <- df4[[mult_col]]
if (length(unique(mult_values[!is.na(mult_values)])) > 1) {
df5 <- remove_multiplicity(df4, peptide_col, mult_col, gn_idx)
} else {
df5 <- df4
}
View(df5)
add_multiplicity <- function(df, peptide_col) {
count_lower <- stringr::str_count(df[[peptide_col]], "[a-z]")
count_star <- stringr::str_count(df[[peptide_col]], "\\*")
df$Multiplicity <- count_lower + count_star
return(df)
}
df = df3
count_lower <- stringr::str_count(df[[peptide_col]], "[a-z]")
df[[peptide_col]]
peptide_col
# Step 3: Check if peptide_col_name is provided and exists in df
if (!is.null(peptide_col_name) && peptide_col_name %in% colnames(df)) {
peptide_col <- peptide_col_name
} else {
peptide_col <- NULL
}
if (!is.null(peptide_col))
# Step 4: Clean multiple peptides
df3 <- clean_multiple_peptide(df2, peptide_col)
# Step 5: Add multiplicity information
df4 <- add_multiplicity(df3, peptide_col)
mult_col <- which(colnames(df4) == "Multiplicity")
mult_values <- df4[[mult_col]]
if (length(unique(mult_values[!is.na(mult_values)])) > 1) {
df5 <- remove_multiplicity(df4, peptide_col, mult_col, gn_idx)
} else {
df5 <- df4
}
View(df5)
# Re-identify site column after modifications
site_col <- which(colnames(df5) == "Site")
# Step 7: Modify peptides to capitalize phosphorylated aminoacids
df6 <- modify_peptide(df5, mult_col, peptide_col, site_col)
# Step 8: Choose phosphopeptides
df7 <- split_peptide(df6, mult_col, peptide_col)
# Step 9: Add sequence window around the peptide
df8 <- add_sequence_window(df7, peptide_col, seq_len_i, sequence_col)
split_peptide
View(df7)
# Step 9: Add sequence window around the peptide
df8 <- add_sequence_window(df7, peptide_col, seq_len_i, sequence_col)
debug(add_sequence_window)
# Step 9: Add sequence window around the peptide
df8 <- add_sequence_window(df7, peptide_col, seq_len_i, sequence_col)
add_sequence_window <- function(phospho_df = df7, peptide_col, seq_len_i = 7, sequence_col) {
phospho_df$sequence_window <- NA
for (i in 1:nrow(phospho_df)) {
peptide <- as.character(phospho_df[[peptide_col]][i])
sequence <- as.character(phospho_df[[sequence_col]][i])
pos_lower <- regexpr("[a-z]", peptide)[1]
pos_star <- regexpr("\\*", peptide)[1]
if (pos_lower != -1) {
phosphorylated_residue <- substr(peptide, pos_lower, pos_lower)
central_pos_offset <- pos_lower
} else if (pos_star != -1) {
phosphorylated_residue <- substr(peptide, pos_star - 1, pos_star - 1)
central_pos_offset <- pos_star - 1
} else {
phospho_df$sequence_window[i] <- NA
next
}
phosphorylated_residue_upper <- toupper(phosphorylated_residue)
start_pos <- regexpr(toupper(peptide), sequence)[1]
if (start_pos == -1) {
phospho_df$sequence_window[i] <- NA
next
}
central_pos <- start_pos + central_pos_offset - 1
start <- max(1, central_pos - seq_len_i)
end <- min(nchar(sequence), central_pos + seq_len_i)
window <- substr(sequence, start, end)
if (start == 1) {
window <- paste0(strrep("_", seq_len_i - (central_pos - 1)), window)
}
if (end == nchar(sequence)) {
window <- paste0(window, strrep("_", seq_len_i - (nchar(sequence) - central_pos)))
}
required_length <- 2 * seq_len_i + 1
current_length <- nchar(window)
if (current_length < required_length) {
total_padding <- required_length - current_length
padding_left <- total_padding %/% 2
padding_right <- total_padding - padding_left
window <- paste0(strrep("_", padding_left), window, strrep("_", padding_right))
}
phospho_df$sequence_window[i] <- window
}
return(phospho_df)
}
# Step 9: Add sequence window around the peptide
df8 <- add_sequence_window(df7, peptide_col, seq_len_i, sequence_col)
View(df8)
# Step 10: Update amino acid positions based on the sequence window
df9 <- update_position_aa(df8, sw_col, sequence_col, peptide_col)
sw_col <- which(colnames(df8) == "sequence_window")
# Step 10: Update amino acid positions based on the sequence window
df9 <- update_position_aa(df8, sw_col, sequence_col, peptide_col)
# Reorder and clean the dataframe columns
df9 <- df9 %>% relocate(sequence_window, UNIPROT) %>%
dplyr::select(-Sequence, -Site, -Peptide)
# Reorder and clean the dataframe columns
df9 <- df9 %>% relocate(sequence_window, UNIPROT) %>%
dplyr::select(-Sequence, -Site, -Peptide)
df9 <- df9[, -ncol(df9)]
View(df9)
phospho_upd <- update_phospho(phospho, 2, 1, peptide_col_name = "Peptide")
# Step 5: Add multiplicity information
df4 <- add_multiplicity(df3, peptide_col)
View(df4)
mult_col <- which(colnames(df4) == "Multiplicity")
mult_values <- df4[[mult_col]]
mult_values <- df4[[mult_col]]
if (length(unique(mult_values[!is.na(mult_values)])) > 1) {
df5 <- remove_multiplicity(df4, peptide_col, mult_col, gn_idx)
} else {
df5 <- df4
}
#' update_phospho
#'
#' This function processes phosphoproteomics data by performing several steps of data cleaning,
#' peptide modification, and enrichment of sequence information. It is designed to handle datasets
#' with phosphopeptides, modifying peptide sequences, adding multiplicity information, and computing
#' sequence windows around the phosphopeptides.
#'
#' @param df dataframe (phosphoproteomics data).
#' @param site_col integer, the column index for phosphorylation site information.
#' @param gn_idx integer, the column index for gene names in the data frame.
#' @param seq_len_i integer, the length of the sequence window to be considered around the phosphopeptide.
#' @param uniprot_idx optional integer indicating the column index for UNIPROT IDs to be added at the uniprot column retrieved with AnnotationDbi (default is NULL).
#' @param peptide_col a string representing the name of the peptide column in the data frame.
#'                         If not provided, the function assumes no peptide column exists.
#'
#' @return A data frame with the processed phosphoproteomics data, including modified peptide sequences,
#' updated amino acid positions, and sequence windows. If no peptide column is provided, the function
#' directly computes amino acid positions.
#' @export
#' @examples
#' # Example usage:
#' updated_phospho_df <- update_phospho(phospho_data, site_col = 3, gn_idx = 2, seq_len_i = 7, peptide_col_name = "Peptide")
#' head(updated_phospho_df)
#'
update_phospho <- function(df, site_col, gn_idx, seq_len_i=7, uniprot_idx = NULL, peptide_col_name = NULL) {
# Step 1: Clear invalid sites
df1 <- remove_invalid_site(df, site_col)
# Step 2: Retrieve primary gene names
df2 <- retrieve_primary_gene_name(df1, gn_idx, uniprot_idx)
# Identify the sequence column
sequence_col <- which(colnames(df2) == "Sequence")
# Step 3: Check if peptide_col_name is provided and exists in df
if (!is.null(peptide_col_name) && peptide_col_name %in% colnames(df)) {
peptide_col <- peptide_col_name
} else {
peptide_col <- NULL
}
if (!is.null(peptide_col)) {
# Step 4: Clean multiple peptides
df3 <- clean_multiple_peptide(df2, peptide_col)
# Step 5: Add multiplicity information
df4 <- add_multiplicity(df3, peptide_col)
mult_col <- which(colnames(df4) == "Multiplicity")
mult_values <- df4[[mult_col]]
if (length(unique(mult_values[!is.na(mult_values)])) > 1) {
df5 <- remove_multiplicity(df4, peptide_col, mult_col, gn_idx)
} else {
df5 <- df4
}
# Re-identify site column after modifications
site_col <- which(colnames(df5) == "Site")
# Step 7: Modify peptides to capitalize phosphorylated aminoacids
df6 <- modify_peptide(df5, mult_col, peptide_col, site_col)
# Step 8: Choose phosphopeptides
df7 <- split_peptide(df6, mult_col, peptide_col)
# Step 9: Add sequence window around the peptide
df8 <- add_sequence_window(df7, peptide_col, seq_len_i, sequence_col)
sw_col <- which(colnames(df8) == "sequence_window")
# Step 10: Update amino acid positions based on the sequence window
df9 <- update_position_aa(df8, sw_col, sequence_col, peptide_col)
# Reorder and clean the dataframe columns
df9 <- df9 %>% relocate(sequence_window, UNIPROT) %>%
dplyr::select(-Sequence, -Site, -Peptide)
df9 <- df9[, -ncol(df9)]
} else {
# If no peptide column is provided, directly create amino acid position
df9 <- create_aa_position(df2, site_col)
# Reorder and clean the dataframe columns
df9 <- df9 %>%
dplyr::relocate(UNIPROT, aminoacid, position) %>%
dplyr::select(-Sequence, -Site)
}
return(df9)
}
library(readr)
library(dplyr)
folder <- "~/Desktop/Lab/Projets/PatientProfiler_analysis/PatientProfiler-main/R/"
file_scripts <- list.files(folder, pattern = "\\.R$", full.names = TRUE)
for (file in file_scripts) {
source(file)
}
phospho_upd <- update_phospho(phospho, 2, 1, peptide_col_name = "Peptide")
Sys.time()
t0 <- Sys.time()
t0
t1(Sys.time())
t1 <- Sys.time()
print(t1-t0)
t1 <- Sys.time()
print(paste0("---- Update finished: ",t1-t0,"----"))
t0 <- Sys.time()
t1 <- Sys.time()
print(paste0("---- Update finished: ",t1-t0,"----"))
t1-t0
t1 <- Sys.time()
elapsed <- round(as.numeric(difftime(t1, t0, units = "secs")), 2)
message("\n──────────────────────────────────────────────")
message("✅  Update finished successfully!")
message(paste("⏱  Elapsed time:", elapsed, "seconds"))
message(paste("🕒  Completed at:", format(t1, "%H:%M:%S")))
message("──────────────────────────────────────────────\n")
t1 <- Sys.time()
elapsed_secs <- as.numeric(difftime(t1, t0, units = "secs"))
if (elapsed_secs < 60) {
elapsed_pretty <- paste0(round(elapsed_secs, 2), " seconds")
} else {
elapsed_pretty <- paste0(round(elapsed_secs / 60, 2), " minutes")
}
message(paste0("\n✅ Update completed in ", elapsed_pretty, "."))
t1 <- Sys.time()
elapsed_secs <- as.numeric(difftime(t1, t0, units = "secs"))
if (elapsed_secs < 60) {
elapsed_pretty <- paste0(round(elapsed_secs, 2), " seconds")
} else {
elapsed_pretty <- paste0(round(elapsed_secs / 60, 2), " minutes")
}
message(paste0("\n Update completed in ", elapsed_pretty, "."))
phospho_upd <- update_phospho(phospho, 2, 1, peptide_col_name = "Peptide")
library(readr)
library(dplyr)
folder <- "~/Desktop/Lab/Projets/PatientProfiler_analysis/PatientProfiler-main/R/"
file_scripts <- list.files(folder, pattern = "\\.R$", full.names = TRUE)
for (file in file_scripts) {
source(file)
}
phospho_upd <- update_phospho(phospho, 2, 1, peptide_col_name = "Peptide")
View(phospho_upd)
mice
library(mice)
mice
?mice
setwd("../../GitHub_SaccoPerfetto/PatientProfiler/")
devtools::document()
